#!/usr/bin/env python3

# SPDX-FileCopyrightText: Chris Braun (cryzed) <cryzed@googlemail.com>
#
# SPDX-License-Identifier: GPL-3.0-or-later

"""
Insert login information using Bitwarden CLI and a dmenu-compatible application
(e.g. dmenu, rofi -dmenu, ...).
"""

USAGE = """The domain of the site has to be in the name of the Bitwarden entry, for example: "github.com/cryzed" or
"websites/github.com".  The login information is inserted by emulating key events using qutebrowser's fake-key command in this manner:
[USERNAME]<Tab>[PASSWORD], which is compatible with almost all login forms.

If enabled, with the `--totp` flag, it will also move the TOTP code to the
clipboard, much like the Firefox add-on.

You must log into Bitwarden CLI using `bw login` prior to use of this script.
The session key will be stored in $XDG_RUNTIME_DIR.

To use in qutebrowser, run: `spawn --userscript qute-bitwarden`
"""

EPILOG = """Dependencies: tldextract (Python 3 module), pyperclip (optional
Python module, used for TOTP codes), Bitwarden CLI (1.7.4 is known to work
but older versions may well also work)

WARNING: The login details are viewable as plaintext in qutebrowser's debug log
(qute://log) and might be shared if you decide to submit a crash report!"""

import argparse
import enum
import functools
import os
import shlex
import subprocess
import sys
import json
import tldextract
import time
import threading

argument_parser = argparse.ArgumentParser(
    description=__doc__,
    usage=USAGE,
    epilog=EPILOG,
)
argument_parser.add_argument("url", nargs="?", default=os.getenv("QUTE_URL"))
argument_parser.add_argument(
    "--dmenu-invocation",
    "-d",
    default="rofi -dmenu -i -p Bitwarden",
    help="Invocation used to execute a dmenu-provider",
)
argument_parser.add_argument(
    "--password-prompt-invocation",
    "-p",
    default='rofi -dmenu -p "Master Password" -password -lines 0',
    help="Invocation used to prompt the user for their Bitwarden password",
)
argument_parser.add_argument(
    "--no-insert-mode",
    "-n",
    dest="insert_mode",
    action="store_false",
    help="Don't automatically enter insert mode",
)
argument_parser.add_argument(
    "--totp", "-t", action="store_true", help="Copy TOTP key to clipboard"
)
argument_parser.add_argument(
    "--io-encoding",
    "-i",
    default="UTF-8",
    help="Encoding used to communicate with subprocesses",
)
argument_parser.add_argument(
    "--merge-candidates",
    "-m",
    action="store_true",
    help="Merge pass candidates for fully-qualified and registered domain name",
)
group = argument_parser.add_mutually_exclusive_group()
group.add_argument(
    "--username-only", "-e", action="store_true", help="Only insert username"
)
group.add_argument(
    "--password-only", "-w", action="store_true", help="Only insert password"
)
group.add_argument(
    "--totp-only", "-T", action="store_true", help="Only insert totp code"
)
argument_parser.add_argument(
    "--refresh-cache", "-r", action="store_true", help="Force refresh the vault cache"
)

stderr = functools.partial(print, file=sys.stderr)


class ExitCodes(enum.IntEnum):
    SUCCESS = 0
    FAILURE = 1
    # 1 is automatically used if Python throws an exception
    NO_PASS_CANDIDATES = 2
    COULD_NOT_MATCH_USERNAME = 3
    COULD_NOT_MATCH_PASSWORD = 4


def qute_command(command):
    with open(os.environ["QUTE_FIFO"], "w") as fifo:
        fifo.write(command + "\n")
        fifo.flush()


def ask_password(password_prompt_invocation):
    """Retrieve Bitwarden master password from env or prompt the user."""
    master_pass = os.getenv("BITWARDEN_PASSWORD")
    if master_pass is None:
        process = subprocess.run(
            shlex.split(password_prompt_invocation),
            text=True,
            stdout=subprocess.PIPE,
        )
        if process.returncode > 0:
            raise Exception("Could not unlock vault")
        master_pass = process.stdout.strip()

    return subprocess.check_output(
        ["bw", "unlock", "--raw", master_pass],
        text=True,
    ).strip()


def get_cache_file_path():
    """Get the path to store the cached vault items."""
    runtime_dir = os.getenv("XDG_RUNTIME_DIR", "/tmp")
    return os.path.join(runtime_dir, "bw_vault_cache.json")


def get_cache_timestamp_file_path():
    """Get the path to store the cache timestamp."""
    runtime_dir = os.getenv("XDG_RUNTIME_DIR", "/tmp")
    return os.path.join(runtime_dir, "bw_vault_cache_timestamp")


def is_cache_valid(max_age_seconds=3600):
    """Check if the cache is still valid (default: 1 hour)."""
    timestamp_file = get_cache_timestamp_file_path()
    if not os.path.exists(timestamp_file):
        return False
    
    try:
        with open(timestamp_file, "r", encoding="utf-8") as f:
            timestamp = float(f.read().strip())
        return (time.time() - timestamp) < max_age_seconds
    except (ValueError, FileNotFoundError):
        return False


def get_all_vault_items(encoding, password_prompt_invocation, use_cache=True):
    """Get all vault items, using cache if available and valid."""
    cache_file = get_cache_file_path()
    timestamp_file = get_cache_timestamp_file_path()
    
    # Check if we can use cached data
    if use_cache and is_cache_valid() and os.path.exists(cache_file):
        try:
            with open(cache_file, "r", encoding="utf-8") as f:
                return json.load(f)
        except (json.JSONDecodeError, FileNotFoundError):
            pass  # Fall through to fetch fresh data
    
    # Fetch fresh data from bitwarden
    session_key = get_session_key(password_prompt_invocation)
    process = subprocess.run(
        ["bw", "list", "items", "--session", session_key],
        capture_output=True,
    )
    
    err = process.stderr.decode(encoding).strip()
    if err:
        stderr(f"Bitwarden CLI error when fetching all items: {err}")
        return []
    
    if process.returncode:
        return []
    
    try:
        items = json.loads(process.stdout.decode(encoding).strip())
        
        # Cache the result
        with open(cache_file, "w", encoding="utf-8") as f:
            json.dump(items, f)
        
        # Update timestamp
        with open(timestamp_file, "w", encoding="utf-8") as f:
            f.write(str(time.time()))
        
        return items
    except json.JSONDecodeError:
        return []


def filter_items_by_domain(items, domain):
    """Filter cached items by domain/URL matching."""
    if not items:
        return []
    
    matching_items = []
    domain_lower = domain.lower()
    
    for item in items:
        # Skip items without login data
        if not item.get("login") or item.get("type") != 1:
            continue
        
        # Check URIs
        uris = item.get("login", {}).get("uris", [])
        for uri_obj in uris:
            uri = uri_obj.get("uri", "")
            if domain_lower in uri.lower():
                matching_items.append(item)
                break
        
        # Also check the item name
        name = item.get("name", "").lower()
        if domain_lower in name:
            matching_items.append(item)
    
    return matching_items


def refresh_cache_async(encoding, password_prompt_invocation):
    """Refresh the cache in a background thread."""
    def refresh():
        try:
            get_all_vault_items(encoding, password_prompt_invocation, use_cache=False)
        except Exception as e:
            stderr(f"Background cache refresh failed: {e}")
    
    thread = threading.Thread(target=refresh, daemon=True)
    thread.start()


def get_session_file_path():
    """Get the path to store the session key."""
    runtime_dir = os.getenv("XDG_RUNTIME_DIR", "/tmp")
    return os.path.join(runtime_dir, "bw_session_key")


def get_session_key(password_prompt_invocation):
    """Retrieve the session key from the file or prompt for it if not available."""
    session_file = get_session_file_path()
    try:
        if os.path.exists(session_file):
            with open(session_file, "r", encoding="utf-8") as f:
                return f.read().strip()
        else:
            session = ask_password(password_prompt_invocation)
            with open(session_file, "w", encoding="utf-8") as f:
                f.write(session)
            return session
    except Exception as e:
        stderr(f"Error managing session key: {e}")
        raise


def pass_(domain, encoding, password_prompt_invocation):
    """Get password candidates for a domain using cached data."""
    # Get all vault items (cached or fresh)
    all_items = get_all_vault_items(encoding, password_prompt_invocation)
    
    # Filter by domain locally
    matching_items = filter_items_by_domain(all_items, domain)
    
    # Start background refresh if cache is getting old (75% of max age)
    if is_cache_valid(max_age_seconds=2700):  # 45 minutes
        refresh_cache_async(encoding, password_prompt_invocation)
    
    return json.dumps(matching_items)


def get_totp_code(selection_id, domain_name, encoding, password_prompt_invocation):
    session_key = get_session_key(password_prompt_invocation)
    process = subprocess.run(
        ["bw", "get", "totp", "--session", session_key, selection_id],
        capture_output=True,
    )

    err = process.stderr.decode(encoding).strip()
    if err:
        # domain_name instead of selection_id to make it more user-friendly
        msg = "Bitwarden CLI returned for {:s} - {:s}".format(domain_name, err)
        stderr(msg)

    if process.returncode:
        return "[]"

    out = process.stdout.decode(encoding).strip()

    return out


def dmenu(items, invocation, encoding):
    command = shlex.split(invocation)
    process = subprocess.run(
        command, input="\n".join(items).encode(encoding), stdout=subprocess.PIPE
    )
    return process.stdout.decode(encoding).strip()


def fake_key_raw(text):
    for character in text:
        # Escape all characters by default, space requires special handling
        sequence = '" "' if character == " " else r"\{}".format(character)
        qute_command("fake-key {}".format(sequence))


def main(arguments):
    # Handle cache refresh option
    if arguments.refresh_cache:
        stderr("Refreshing vault cache...")
        get_all_vault_items(arguments.io_encoding, arguments.password_prompt_invocation, use_cache=False)
        stderr("Cache refreshed successfully!")
        return ExitCodes.SUCCESS

    if not arguments.url:
        argument_parser.print_help()
        return ExitCodes.FAILURE

    extract_result = tldextract.extract(arguments.url)

    # Try to find candidates using targets in the following order: fully-qualified domain name (includes subdomains),
    # the registered domain name and finally: the IPv4 address if that's what
    # the URL represents
    candidates = []
    for target in filter(
        None,
        [
            extract_result.fqdn,
            extract_result.registered_domain,
            extract_result.subdomain + "." + extract_result.domain,
            extract_result.domain,
            extract_result.ipv4,
        ],
    ):
        target_candidates = json.loads(
            pass_(
                target,
                arguments.io_encoding,
                arguments.password_prompt_invocation,
            )
        )
        if not target_candidates:
            continue

        candidates = candidates + target_candidates
        if not arguments.merge_candidates:
            break
    else:
        if not candidates:
            stderr("No pass candidates for URL {!r} found!".format(arguments.url))
            return ExitCodes.NO_PASS_CANDIDATES

    if len(candidates) == 1:
        selection = candidates.pop()
    else:
        choices = [
            "{:s} | {:s}".format(c["name"], c["login"]["username"]) for c in candidates
        ]
        choice = dmenu(choices, arguments.dmenu_invocation, arguments.io_encoding)
        choice_tokens = choice.split("|")
        choice_name = choice_tokens[0].strip()
        choice_username = choice_tokens[1].strip()
        selection = next(
            (
                c
                for (i, c) in enumerate(candidates)
                if c["name"] == choice_name
                and c["login"]["username"] == choice_username
            ),
            None,
        )

    # Nothing was selected, simply return
    if not selection:
        return ExitCodes.SUCCESS

    username = selection["login"]["username"]
    password = selection["login"]["password"]
    totp = selection["login"]["totp"]

    if arguments.username_only:
        fake_key_raw(username)
    elif arguments.password_only:
        fake_key_raw(password)
    elif arguments.totp_only:
        # No point in moving it to the clipboard in this case
        fake_key_raw(
            get_totp_code(
                selection["id"],
                selection["name"],
                arguments.io_encoding,
                arguments.password_prompt_invocation,
            )
        )
    else:
        # Enter username and password using fake-key and <Tab> (which seems to work almost universally), then switch
        # back into insert-mode, so the form can be directly submitted by
        # hitting enter afterwards
        fake_key_raw(username)
        qute_command("fake-key <Tab>")
        fake_key_raw(password)

    if arguments.insert_mode:
        qute_command("mode-enter insert")

    # If it finds a TOTP code, it copies it to the clipboard,
    # which is the same behavior as the Firefox add-on.
    if not arguments.totp_only and totp and arguments.totp:
        # The import is done here, to make pyperclip an optional dependency
        import pyperclip

        pyperclip.copy(
            get_totp_code(
                selection["id"],
                selection["name"],
                arguments.io_encoding,
                arguments.password_prompt_invocation,
            )
        )

    return ExitCodes.SUCCESS


if __name__ == "__main__":
    arguments = argument_parser.parse_args()
    sys.exit(main(arguments))
