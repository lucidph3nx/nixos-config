#!/usr/bin/env python

import json
import subprocess
import re


def get_pipewire_audio_info():
    """Fetch current audio output sync information from PipeWire."""
    try:
        # Run the pw-dump command to get PipeWire info
        result = subprocess.run(["pw-dump"], capture_output=True, text=True, check=True)
        data = json.loads(result.stdout)

        # Find the default audio sink node from metadata
        default_sink_name = None
        for node in data:
            if (
                node.get("type") == "PipeWire:Interface:Metadata"
                and node.get("props", {}).get("metadata.name") == "default"
            ):
                for meta in node.get("metadata", []):
                    if meta.get("key") == "default.audio.sink":
                        default_sink_name = meta.get("value", {}).get("name")
                        break
        default_source_name = None
        for node in data:
            if (
                node.get("type") == "PipeWire:Interface:Metadata"
                and node.get("props", {}).get("metadata.name") == "default"
            ):
                for meta in node.get("metadata", []):
                    if meta.get("key") == "default.audio.source":
                        default_source_name = meta.get("value", {}).get("name")
                        break

        # Parse to find default sink
        default_sink_info = {}
        for node in data:
            info_props = node.get("info", {}).get("props", {})
            if (
                node.get("type") == "PipeWire:Interface:Node"
                and node.get("info", {}).get("props", {}).get("node.name")
                == default_sink_name
            ):
                default_sink_info = {
                    "id": node.get("id"),
                    "name": info_props.get("node.description", "unknown"),
                }
                # Find the volume for the default sink from PropInfo
                prop_info = node.get("info", {}).get("params", {}).get("PropInfo", [])
                for prop in prop_info:
                    if prop.get("id") == "volume":
                        volume_percent = (
                            prop.get("type", {}).get("default", "unknown") * 100
                        )
                        default_sink_info["volume"] = f"{volume_percent:.0f}%"
                # find the mute status for the default sink from PropInfo
                for prop in prop_info:
                    if prop.get("id") == "mute":
                        default_sink_info["mute"] = prop.get("type", {}).get(
                            "default", "unknown"
                        )

                break  # Stop once we find the default sink
        # Parse to find default source
        default_source_info = {}
        for node in data:
            info_props = node.get("info", {}).get("props", {})
            if (
                node.get("type") == "PipeWire:Interface:Node"
                and node.get("info", {}).get("props", {}).get("node.name")
                == default_source_name
            ):
                default_source_info = {
                    "id": node.get("id"),
                    "name": info_props.get("node.description", "unknown"),
                }

                # Find the volume for the default source from PropInfo
                prop_info = node.get("info", {}).get("params", {}).get("PropInfo", [])
                for prop in prop_info:
                    if prop.get("id") == "volume":
                        volume_percent = (
                            prop.get("type", {}).get("default", "unknown") * 100
                        )
                        default_source_info["volume"] = f"{volume_percent:.0f}%"

                # find the mute status for the default source from PropInfo
                for prop in prop_info:
                    if prop.get("id") == "mute":
                        default_source_info["mute"] = prop.get("type", {}).get(
                            "default", "unknown"
                        )
                break  # Stop once we find the default source
        # return sink info and source info as a json object
        return {
            "default_sink": default_sink_info,
            "default_source": default_source_info,
        }

    except subprocess.CalledProcessError as e:
        print(f"Error calling pw-dump: {e}")
        return []
    except json.JSONDecodeError:
        print("Error decoding JSON from pw-dump.")
        return []


import subprocess


import subprocess


def get_network_status():
    """Fetch current network status using NetworkManager and return only the default network."""
    try:
        # Run nmcli command to get the active connections with NAME, DEVICE, STATE, and TYPE
        result = subprocess.run(
            [
                "nmcli",
                "-t",
                "-f",
                "NAME,DEVICE,STATE,TYPE",
                "connection",
                "show",
                "--active",
            ],
            capture_output=True,
            text=True,
            check=True,
        )

        # Parse the result to get details about the active network
        connections = result.stdout.strip().splitlines()

        for connection in connections:
            fields = connection.split(":")
            name, device, state, conn_type = fields

            # Map the conn_type to simplified type
            if conn_type == "802-3-ethernet":
                conn_type = "ethernet"
            elif conn_type == "802-11-wireless":
                conn_type = "wifi"

            # Check if this is the default network
            if state == "activated":
                # Run nmcli again to get the IP address for the default network device
                ip_result = subprocess.run(
                    ["nmcli", "-g", "IP4.ADDRESS", "device", "show", device],
                    capture_output=True,
                    text=True,
                    check=True,
                )
                ip = ip_result.stdout.strip()

                # Return network info with simplified type
                return {"name": name, "device": device, "type": conn_type, "ip": ip}

        # If no default network found
        return {}

    except subprocess.CalledProcessError as e:
        print(f"Error calling nmcli: {e}")
        return {}

    except subprocess.CalledProcessError as e:
        print(f"Error calling nmcli: {e}")
        return {}


def get_mouse_battery_status():
    try:
        # Run the polychromatic-cli command to get mouse info
        result = subprocess.run(
            ["polychromatic-cli", "-d", "mouse", "-k"],
            capture_output=True,
            text=True,
            check=True,
        )

        # Extract battery information
        battery_info_line = None
        for line in result.stdout.splitlines():
            if "Battery" in line:
                battery_info_line = line
                break

        if battery_info_line:
            # Match battery percentage and charging status using regex
            match = re.search(r"(\d+%)\s*(\((charging)\))?", battery_info_line)
            if match:
                battery_percentage = match.group(1)
                charging_status = bool(
                    match.group(3)
                )  # True if 'charging' is present, otherwise False

                # Determine if the battery is low (less than 20%)
                battery_value = int(battery_percentage.strip("%"))
                battery_low = battery_value < 20

                # Construct the status string
                status = (
                    f"{battery_percentage} (charging)"
                    if charging_status
                    else battery_percentage
                )

                return {
                    "battery_percentage": battery_percentage,
                    "charging": charging_status,
                    "battery_low": battery_low,
                    "status": status,
                }
            else:
                return {
                    "battery": "unknown",
                    "charging": False,
                    "battery_low": False,
                    "status": "unknown",
                }
        else:
            return {
                "battery": "unknown",
                "charging": False,
                "battery_low": False,
                "status": "unknown",
            }

    except subprocess.CalledProcessError as e:
        print(f"Error calling polychromatic-cli: {e}")
        return {
            "battery": "unknown",
            "charging": False,
            "battery_low": False,
            "status": "unknown",
        }


def get_host_info():
    try:
        # Run the hostnamectl command to get host info
        result = subprocess.run(
            ["hostnamectl"], capture_output=True, text=True, check=True
        )

        # Initialize a dictionary to store the host info
        host_info = {
            "name": None,
            "kernel": None,
            "architecture": None,
            "operating_system": None,
        }

        # Parse each line to extract relevant information
        for line in result.stdout.splitlines():
            if "Static hostname" in line:
                host_info["name"] = line.split(":")[1].strip()
            elif "Kernel" in line:
                host_info["kernel"] = line.split(":")[1].strip()
            elif "Architecture" in line:
                host_info["architecture"] = line.split(":")[1].strip()
            elif "Operating System" in line:
                host_info["operating_system"] = line.split(":")[1].strip()

        # Return the host information
        return {"host": host_info}

    except subprocess.CalledProcessError as e:
        print(f"Error calling hostnamectl: {e}")
        return {
            "host": {
                "name": "unknown",
                "kernel": "unknown",
                "architecture": "unknown",
                "operating_system": "unknown",
            }
        }


def main():
    host_info = get_host_info()
    audio = get_pipewire_audio_info()
    network = get_network_status()
    mouse = get_mouse_battery_status()

    # Produce a simplified JSON output
    output = {
        "host": host_info,
        "audio": audio,
        "network": network,
        "mouse": mouse,
    }

    print(json.dumps(output, indent=2))


if __name__ == "__main__":
    main()
